using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class newInput : MonoBehaviour {
	public string inputCombo;

	public GameObject happyFace, sadFace, loveFace;
	public GameObject flatter, joke, wink, chat, neutral;
	public Text meterText;
	public Text timeText;

	public bool comboOver;
	public bool StopButtons;
	public int preferedLength;
	public int maxUsage;//max usage of a combo before "overused"
	public Combo[] premadeCombos;
	List<Combo> comboUsage = new List<Combo> ();

	//Dictionary<string, int> comboUsage;
	// Use this for initialization
	void Start () {
		
		foreach(Combo combo in premadeCombos) {///RUns slowly will need to improve
			
			comboUsage.Add (combo);
			//print (comboUsage. + " has been added to list, used  "+comboInfo[1]);
		}
	}
	
	// Update is called once per frame
	void Update () {
		//Get player input. 
		if (inputCombo.Length < 5 && comboOver == false) {
			if (Input.GetKeyDown (KeyCode.A)) {
				inputCombo += "A";
				Debug.Log ("Your combo so far: " + inputCombo);

			} else if (Input.GetKeyDown (KeyCode.W)) {
				inputCombo += "W";
				Debug.Log ("Your combo so far: " + inputCombo);
			} else if (Input.GetKeyDown (KeyCode.S)) {
				inputCombo += "S";
				Debug.Log ("Your combo so far: " + inputCombo);
			} else if (Input.GetKeyDown (KeyCode.D)) {
				inputCombo += "D";
				Debug.Log ("Your combo so far: " + inputCombo);
			}
			else if(Input.GetKeyDown(KeyCode.Space)){
				comboOver = true;
				//Debug.Log ("Press [R] to reset: Info>> " + compareCombo (preferedLength, inputCombo, premadeCombos));
				print ("Press [R] to reset: Info>> " + compareCombo (preferedLength, inputCombo, premadeCombos, comboUsage));
			}

		}
		else { 
			if(Input.GetKeyDown(KeyCode.R)){ 
				comboOver = false;
				inputCombo = "";
				Debug.Log ("I reset the combo, see :" + inputCombo);
			}
		}
	}

	//<-------------------------------Functions----------------------->
	string compareCombo(int preferedComboLength, string playerCombo, string[] comboStats){ 
		/*the length that we want the combo to be (3-5), 
		 *the combo generated by the player, 
		 *the list of combo we've given meaning to.
		*/

		string isIt = "";//the final string of info
		bool premade = false;

		//testing length
		if(playerCombo.Length>preferedLength){ isIt += "long";}
		else{ isIt += "fit";}//langauge reflects length in attempts for improved readability

		for(int i = 0; i<comboStats.Length; i++)//Checks if the inputCOmbo exist in the combo list
		{
			if(comboStats[i].Equals( playerCombo)){
				isIt += " " + i;
				premade = true;
				Debug.Log ("We checked "+i+" and that was one.  >" + playerCombo);
				break;
			} 


		}
		if(premade==false){
			isIt+=" -1 never";
			Combo newCombo = new Combo (inputCombo);
			comboUsage.Add (newCombo);
		}//combos not on the list are denoted by -1, usage as "never"

		if(premade == true){
			isIt+="";
		}
		return isIt;
	}


	//compareCombo v2, now uses/needs a dictionary
	string compareCombo(int preferedComboLength, string playerCombo, Combo[] premadeComboList, List<Combo> usedCombos){
		string isIt = "";//the final string of info
		bool correctLength = false;
		bool premade = false;
		bool usedAlready = false;
		//testing length
		if(playerCombo.Length>preferedLength){ correctLength = true;}
		else{ isIt += "fit";}//langauge reflects length in attempts for improved readability

		//is this a premade combo
//		if(premadeComboList.Contains(playerCombo)==true){
//			isIt+=" premade";
//		} else { isIt+=" random";}
		foreach(Combo combo in premadeComboList){//checks if the combo is premade or not.
			int i =0;
			if (premadeComboList[i].comboInput.Equals(playerCombo)){
				premade = true;
				break;
			}
			i++;
		}
		foreach(Combo combo in usedCombos){//checks if  the  combo has been used before, and increments usage.
			int i = 0;
			if(usedCombos[i].comboInput.Equals(playerCombo)){
				usedAlready = true;
				usedCombos[i].usage+=1;
				break;
			}

			i++;
		}
		if(usedAlready==false){//adds the combo to the COmbo List, if necessary
			Combo newCombo = new Combo(playerCombo);
			usedCombos.Add(newCombo);
		}
//		if(usedCombos.Contains(playerCombo))
//		{ 
//			print ("used b4" + premadeComboList [playerCombo]);
//			usedCombos [playerCombo].usage += 1;
//			print ("used after " + premadeComboList [playerCombo]);
//			isIt += " used: " + usedCombos [playerCombo].usage;
//			print ("You've used this combo "+usedCombos[playerCombo].comboInput+" times!");
//		}
//		else{
//			print ("NEW COMBO ADDED!");
//			Combo newCombo = new Combo (playerCombo);
//			usedCombos.Add (newCombo);
//		}
		isIt = "Lenght?>"+correctLength+". Premade?>"+ premade+". New Combo?>"+usedAlready;
		return isIt;
	}

	bool contains(string input, string[] list ){
		bool contained = false;

		for(int i = 0; i<list.Length-1;i++){
			if(list[i].Equals(input)){ contained = true; break;}
		}
		return contained;
	}
}






