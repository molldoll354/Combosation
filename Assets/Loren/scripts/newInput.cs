using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class newInput : MonoBehaviour {
	public string inputCombo;

	public GameObject happyFace, sadFace, loveFace;
	public GameObject flatter, joke, wink, chat, neutral;
	public Text meterText;
	public Text timeText;

	public bool comboOver;
	public bool StopButtons;
	public int preferedLength;
	public int maxUsage;//max usage of a combo before "overused"
	public string[] combos;
	//List<string[]> comboUsage;

	Dictionary<string, int> comboUsage;
	// Use this for initialization
	void Start () {
		comboUsage = new Dictionary<string, int> ();
		foreach(string combo in combos) {///RUns slowly will need to improve
			
			comboUsage.Add (""+combo, 0);
			//print (comboUsage. + " has been added to list, used  "+comboInfo[1]);
		}
	}
	
	// Update is called once per frame
	void Update () {
		//Get player input. 
		if (inputCombo.Length < 5 && comboOver == false) {
			if (Input.GetKeyDown (KeyCode.A)) {
				inputCombo += "A";
				Debug.Log ("Your combo so far: " + inputCombo);

			} else if (Input.GetKeyDown (KeyCode.W)) {
				inputCombo += "W";
				Debug.Log ("Your combo so far: " + inputCombo);
			} else if (Input.GetKeyDown (KeyCode.S)) {
				inputCombo += "S";
				Debug.Log ("Your combo so far: " + inputCombo);
			} else if (Input.GetKeyDown (KeyCode.D)) {
				inputCombo += "D";
				Debug.Log ("Your combo so far: " + inputCombo);
			}
			else if(Input.GetKeyDown(KeyCode.Space)){
				comboOver = true;
				Debug.Log ("Press [R] to reset: Info>> " + compareCombo (preferedLength, inputCombo, combos));
				print ("Press [R] to reset: Info>> " + compareCombo (preferedLength, inputCombo, combos, comboUsage));
			}

		}
		else { 
			if(Input.GetKeyDown(KeyCode.R)){ 
				comboOver = false;
				inputCombo = "";
				Debug.Log ("I reset the combo, see :" + inputCombo);
			}
		}
	}

	//<-------------------------------Functions----------------------->
	string compareCombo(int preferedComboLength, string playerCombo, string[] comboStats){ 
		/*the length that we want the combo to be (3-5), 
		 *the combo generated by the player, 
		 *the list of combo we've given meaning to.
		*/

		string isIt = "";//the final string of info
		bool premade = false;

		//testing length
		if(playerCombo.Length>preferedLength){ isIt += "long";}
		else{ isIt += "fit";}//langauge reflects length in attempts for improved readability

		for(int i = 0; i<comboStats.Length; i++)//Checks if the inputCOmbo exist in the combo list
		{
			if(comboStats[i].Equals( playerCombo)){
				isIt += " " + i;
				premade = true;
				Debug.Log ("We checked "+i+" and that was one.  >" + playerCombo);
				break;
			} 


		}
		if(premade==false){isIt+=" -1 never";}//combos not on the list are denoted by -1, usage as "never"

		if(premade == true){
			isIt+="";
		}
		return isIt;
	}


	//compareCombo v2, now uses/needs a dictionary
	string compareCombo(int preferedComboLength, string playerCombo, string[] comboList, Dictionary<string,int> comboStats){
		string isIt = "";//the final string of info
		bool premade = false;
		//testing length
		if(playerCombo.Length>preferedLength){ isIt += "long";}
		else{ isIt += "fit";}//langauge reflects length in attempts for improved readability

		//is this a premade combo
		if(contains(playerCombo,comboList)==true){
			isIt+=" premade";
		} else { isIt+=" random";}
		if(comboStats.ContainsKey(playerCombo))
		{ 
			print ("used b4" + comboStats [playerCombo]);
			comboStats [playerCombo] += 1;
			print ("used after " + comboStats [playerCombo]);
			isIt += " used: " + comboStats [playerCombo];
			print ("You've used this combo "+comboStats[playerCombo]+" times!");
		}
		else{
			print ("NEW COMBO ADDED!");
			comboStats.Add (playerCombo, 0);
		}
		return isIt;
	}

	bool contains(string input, string[] list ){
		bool contained = false;

		for(int i = 0; i<list.Length-1;i++){
			if(list[i].Equals(input)){ contained = true;}
		}
		return contained;
	}
}






